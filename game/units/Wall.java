package game.units;

import game.Game;
import game.calculations.Calculations;
import game.calculations.Cardinal;
import game.calculations.Maths;
import game.calculations.Vector2D;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Point2D.Double;
import java.awt.geom.Rectangle2D;


public class Wall implements Drawable {

	private static final long serialVersionUID = 1L;

	public enum Orientation{
		VERTICAL,
		HORIZONTAL
	}

	/*
	 * for walls generated by the player, start as square and expand
	 * p: the center point of the wall
	 */
	public Wall(Point2D.Double p, Orientation orientation){
		this.rect = new Rectangle2D.Double(p.getX() - (WIDTH / 2), p.getY() - (HEIGHT / 2), WIDTH, HEIGHT);
		west = new Line2D.Double(rect.x,rect.y, rect.x, rect.y + rect.height);
		north = new Line2D.Double(rect.x,rect.y,rect.x + rect.width, rect.y);
		east = new Line2D.Double(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height);
		south = new Line2D.Double(rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height);
		this.orientation = orientation;
		Rectangle2D.Double quadrant = Calculations.getQuadrant(getCenterPoint(), Game.gameField.getWalls());
		switch(orientation){
		case VERTICAL:
			minX = p.x - (WIDTH / 2);
			maxX = p.x + (WIDTH / 2);
			minY = quadrant.getMinY();
			maxY = quadrant.getMaxY();
			growingNorth = growingSouth = true;
			growingWest = growingEast = false;
			break;
		case HORIZONTAL:
			minX = quadrant.getMinX();
			maxX = quadrant.getMaxX();
			minY = p.y - (HEIGHT / 2);
			maxY = p.y + (HEIGHT / 2);
			growingWest = growingEast = true;
			growingNorth = growingSouth = false;
			break;
		}
	}

	//for pre defined, non-expanding walls
	public Wall(Rectangle2D.Double rect, Orientation orientation){
		this.rect = rect;
		west = new Line2D.Double(rect.x,rect.y, rect.x, rect.y + rect.height);
		north = new Line2D.Double(rect.x,rect.y, rect.x + rect.width, rect.y);
		east = new Line2D.Double(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height);
		south = new Line2D.Double(rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height);
		this.orientation = orientation;
		growingWest = growingNorth = growingEast = growingSouth = false;
	}

	public static final int HEIGHT = 4;//horizontal walls
	public static final int WIDTH = 4;//vertical walls

	private double minX, minY, maxX, maxY, expandSpeed = 5;
	private double projMinX, projMinY, projMaxX, projMaxY;
	private Rectangle2D.Double rect;
	private Orientation orientation;
	private Line2D.Double west,north,east,south;
	private boolean growingWest, growingNorth, growingEast, growingSouth;

	public Rectangle2D.Double getShape(){
		return rect;
	}

	public Orientation getOrientation(){
		return orientation;
	}

	//	public Point2D.Double getULPoint(){
	//		return _UL;
	//	}
	//
	//	public Point2D.Double getURPoint(){
	//		return _UR;
	//	}
	//
	//	public Point2D.Double getLLPoint(){
	//		return _LL;
	//	}
	//
	//	public Point2D.Double getLRPoint(){
	//		return _LR;
	//	}

	public Line2D.Double getWest(){
		return west;
	}

	public Line2D.Double getNorth(){
		return north;
	}

	public Line2D.Double getEast(){
		return east;
	}

	public Line2D.Double getSouth(){
		return south;
	}

	public double getCenterX(){
		return rect.getCenterX();
	}

	public double getCenterY(){
		return rect.getCenterY();
	}
	//projected minX
	public double getMinX(){
		return minX;
	}
	//projected maxX
	public double getMaxX(){
		return maxX;
	}
	//projected minY
	public double getMinY(){
		return minY;
	}
	//projected maxY
	public double getMaxY(){
		return maxY;
	}

	public Point2D.Double getCenterPoint(){
		return new Point2D.Double(rect.getCenterX(), rect.getCenterY());
	}

	public boolean isGrowing(){
		return growingWest || growingNorth || growingEast || growingSouth;
	}

	public void expand(){
		Rectangle2D quadrant = Calculations.getQuadrant(getCenterPoint(), Game.gameField.getWalls());
		if(orientation == Orientation.VERTICAL){
			double northDY = rect.getMinY() - quadrant.getMinY();
			if(northDY > 0){
				//expand north
				rect.y -= expandSpeed < northDY ? expandSpeed : northDY;
				calculateBorders();
			}else growingNorth = false;
			double southDY = quadrant.getMaxY() - rect.getMaxY();
			if(southDY > 0){
				//expand south
				rect.height += expandSpeed * 2 < southDY ? expandSpeed * 2 : southDY;
				calculateBorders();
			}else growingSouth = false;
		}
		if(orientation == Orientation.HORIZONTAL){
			double westDX = rect.getMinX() - quadrant.getMinX();
			if(westDX > 0){
				//expand west
				rect.x -= expandSpeed < westDX ? expandSpeed : westDX;
				calculateBorders();
			}else
				growingWest = false;
			double eastDX = quadrant.getMaxX() - rect.getMaxX();
			if(eastDX > 0){
				//expand east
				rect.width += expandSpeed * 2 < eastDX ? expandSpeed * 2 : eastDX;
				calculateBorders();
			}else
				growingEast = false;
		}
	}

	private void calculateBorders(){
		west = new Line2D.Double(rect.x,rect.y, rect.x, rect.y + rect.height);
		north = new Line2D.Double(rect.x,rect.y,rect.x + rect.width, rect.y);
		east = new Line2D.Double(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height);
		south = new Line2D.Double(rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height);
	}

	public boolean overlaps(Point2D.Double center){
		return overlapsWest(center, Ball.RADIUS) || overlapsNorth(center, Ball.RADIUS) 
				|| overlapsEast(center, Ball.RADIUS) || overlapsSouth(center, Ball.RADIUS);
	}

	public boolean overlapsWest(Point2D.Double center, double radius){
		return west.x1 >= center.x - radius && west.x1 <= center.x + radius
				&& center.y + radius >= north.y1 && center.y - radius <= south.y1;
	}

	public boolean overlapsNorth(Point2D.Double center, double radius){
		return north.y1 >= center.y - radius && north.y1 <= center.y + radius
				&& center.x + radius >= west.x1 && center.x - radius <= east.x1;
	}

	public boolean overlapsEast(Point2D.Double center, double radius){
		return east.x1 >= center.x - radius && east.x1 <= center.x + radius
				&& center.y + radius >= north.y1 && center.y - radius <= south.y1;
	}

	public boolean overlapsSouth(Point2D.Double center, double radius){
		return south.y1 >= center.y - radius && south.y1 <= center.y + radius
				&& center.x + radius >= west.x1 && center.x - radius <= east.x1;
	}

	public void checkCollision(Ball ball, Point2D.Double projectedCenter){
		boolean westCollision = overlapsWest(projectedCenter, Ball.RADIUS);
		boolean northCollision = overlapsNorth(projectedCenter, Ball.RADIUS);
		boolean eastCollision = overlapsEast(projectedCenter, Ball.RADIUS);
		boolean southCollision = overlapsSouth(projectedCenter, Ball.RADIUS);
		//projection is overlapping both west and east sides of wall
		//send back towards where the ball currently is
		if(westCollision && eastCollision){
			ball.getVelocity().x = ball.getCenterPoint().x > rect.getCenterX() ? Maths.positive(ball.getVelocity().x) : Maths.negative(ball.getVelocity().x);
			return;
		}
		//projection is overlapping both north and south sides of wall
		//send back towards where the ball currently is
		if(northCollision && southCollision){
			ball.getVelocity().y = ball.getCenterPoint().y > rect.getCenterY() ?Maths.positive(ball.getVelocity().y) : Maths.negative(ball.getVelocity().y);
			return;
		}
		//West side of rectangle collision
		if(westCollision){
			ball.getVelocity().x = Maths.negative(ball.getVelocity().x);
		}
		//East side of rectangle collision
		if(eastCollision){
			ball.getVelocity().x = Maths.positive(ball.getVelocity().x);
		}
		//North side of rectangle collision
		if(northCollision){
			ball.getVelocity().y = Maths.negative(ball.getVelocity().y);
		}
		//South side of rectangle collision
		if(southCollision){
			ball.getVelocity().y = Maths.positive(ball.getVelocity().y);
		}
	}

	public void determineVelocity(Ball ball, boolean westCollision, boolean eastCollision){
		if(westCollision && eastCollision){
			ball.getVelocity().x = ball.getCenterPoint().x > rect.getCenterX() ? Maths.positive(ball.getVelocity().x) : Maths.negative(ball.getVelocity().x);
		}
		else if(westCollision){		
			ball.getVelocity().x = Maths.negative(ball.getVelocity().x);
		}
		else if(eastCollision){
			ball.getVelocity().x = Maths.positive(ball.getVelocity().x);
		}
	}

	public boolean overlaps(Wall other){
		return (rect.intersects(other.getShape()));
	}

	public boolean willFit(Wall newWall){
		Rectangle2D.Double quadrant = Calculations.getQuadrant(newWall.getCenterPoint(), Game.gameField.getWalls());
		if(newWall == this) return true;
		if(orientation != newWall.getOrientation())
			return true;
		if(orientation == Orientation.HORIZONTAL){
			for(Ball ball : Game.gameField.getBalls()){
				double top = Math.min(north.getY1(), newWall.getNorth().getY1());
				double bottom = Math.max(north.getY1(), newWall.getNorth().getY1());
				//if a Ball is between the two walls, ensure there is enough room
				if(ball.getCenterPoint().getY() > top && ball.getCenterPoint().getY() < bottom && quadrant.contains(ball.getCenterPoint())){
					return (bottom - top > Ball.RADIUS * 2 + HEIGHT + 5);
				}
			}
			return !overlaps(newWall);
		}
		if(orientation == Orientation.VERTICAL){
			for(Ball ball : Game.gameField.getBalls()){
				double left = Math.min(west.getX1(), newWall.getWest().getX1());
				double right = Math.max(west.getX1(), newWall.getWest().getX1());
				//if a Ball is between the two walls, ensure there is enough room
				if(ball.getCenterPoint().getX() > left && ball.getCenterPoint().getX() < right && quadrant.contains(ball.getCenterPoint())){
					return(right - left > Ball.RADIUS * 2 + WIDTH + 5);
				}
			}
			return !overlaps(newWall);
		}
		return false;
	}


	@Override
	public void update() {
		if(isGrowing())
			expand();
	}

	@Override
	public void draw(Graphics g){
		g.setColor(Color.white);
		g.fillRect((int)rect.x, (int)rect.y, (int)rect.width, (int)rect.height);
	}

}
